"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

// These will be generated by genabi.mjs
import { SkillRatingABI } from "@/abi/SkillRatingABI";
import { SkillRatingAddresses } from "@/abi/SkillRatingAddresses";

interface SkillRatingInfo {
  abi: typeof SkillRatingABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
}

export type DimensionScores = {
  codeQuality: number;
  communication: number;
  contribution: number;
  collaboration: number;
  creativity: number;
};

export type EncryptedResults = {
  weightedScore?: string;
  dimensionSums?: {
    codeQuality: string;
    communication: string;
    contribution: string;
    collaboration: string;
    creativity: string;
  };
  ratingCount?: number;
};

export type DecryptedResults = {
  weightedScore?: number;
  dimensions?: {
    codeQuality: number;
    communication: number;
    contribution: number;
    collaboration: number;
    creativity: number;
  };
  ratingCount?: number;
};

export const useSkillRating = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  const [currentRoundId, setCurrentRoundId] = useState<bigint | undefined>(
    undefined
  );
  const [encryptedResults, setEncryptedResults] = useState<
    EncryptedResults | undefined
  >(undefined);
  const [decryptedResults, setDecryptedResults] = useState<
    DecryptedResults | undefined
  >(undefined);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isDecrypting, setIsDecrypting] = useState(false);
  const [message, setMessage] = useState<string>("");

  const getSkillRatingByChainId = useCallback(
    (chainId: number | undefined): SkillRatingInfo => {
      if (!chainId) {
        return { abi: SkillRatingABI.abi };
      }

      const entry =
        SkillRatingAddresses[
          chainId.toString() as keyof typeof SkillRatingAddresses
        ];

      if (!entry || entry.address === ethers.ZeroAddress) {
        return { abi: SkillRatingABI.abi, chainId };
      }

      return {
        address: entry.address as `0x${string}`,
        chainId: entry.chainId ?? chainId,
        chainName: entry.chainName,
        abi: SkillRatingABI.abi,
      };
    },
    []
  );

  const skillRatingInfo = useMemo<SkillRatingInfo>(() => {
    return getSkillRatingByChainId(chainId);
  }, [chainId, getSkillRatingByChainId]);

  // Submit encrypted ratings
  const submitRating = useCallback(
    async (
      rateeAddress: string,
      roundId: bigint,
      scores: DimensionScores
    ) => {
      if (
        !instance ||
        !ethersSigner ||
        !skillRatingInfo.address ||
        !sameChain.current(chainId) ||
        !sameSigner.current(ethersSigner)
      ) {
        throw new Error("Missing required dependencies for rating submission");
      }

      setIsSubmitting(true);
      setMessage("Encrypting ratings...");

      try {
        const thisContractAddress = skillRatingInfo.address;
        const thisSignerAddress = ethersSigner.address;
        const thisChainId = chainId;
        const thisEthersSigner = ethersSigner;

        // Create encrypted input
        const input = instance.createEncryptedInput(
          thisContractAddress,
          thisSignerAddress
        );

        // Add all dimension scores
        input.add32(scores.codeQuality);
        input.add32(scores.communication);
        input.add32(scores.contribution);
        input.add32(scores.collaboration);
        input.add32(scores.creativity);

        // Encrypt (CPU-intensive)
        await new Promise((resolve) => setTimeout(resolve, 100));
        const enc = await input.encrypt();

        if (
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner)
        ) {
          setMessage("Operation cancelled");
          return;
        }

        setMessage("Submitting to contract...");

        // TODO: Call contract.submitRating with encrypted scores
        // const contract = new ethers.Contract(
        //   thisContractAddress,
        //   skillRatingInfo.abi,
        //   thisEthersSigner
        // );
        // const tx = await contract.submitRating(
        //   rateeAddress,
        //   roundId,
        //   enc.handles[0], // codeQuality
        //   enc.handles[1], // communication
        //   enc.handles[2], // contribution
        //   enc.handles[3], // collaboration
        //   enc.handles[4], // creativity
        //   [
        //     enc.inputProof,
        //     enc.inputProof,
        //     enc.inputProof,
        //     enc.inputProof,
        //     enc.inputProof,
        //   ]
        // );
        // await tx.wait();

        setMessage("Rating submitted successfully!");
      } catch (error) {
        console.error("Failed to submit rating:", error);
        setMessage("Failed to submit rating");
        throw error;
      } finally {
        setIsSubmitting(false);
      }
    },
    [instance, ethersSigner, skillRatingInfo, chainId, sameChain, sameSigner]
  );

  // Fetch encrypted results
  const fetchEncryptedResults = useCallback(
    async (rateeAddress: string, roundId: bigint) => {
      if (
        !ethersReadonlyProvider ||
        !skillRatingInfo.address ||
        !sameChain.current(chainId)
      ) {
        return;
      }

      try {
        // TODO: Query contract for encrypted results
        // const contract = new ethers.Contract(
        //   skillRatingInfo.address,
        //   skillRatingInfo.abi,
        //   ethersReadonlyProvider
        // );
        // const ratingCount = await contract.getRatingCount(rateeAddress, roundId);
        // const weightedScore = await contract.calculateWeightedScore(
        //   rateeAddress,
        //   roundId
        // );
        // const dimensionSums = await contract.getDimensionSums(
        //   rateeAddress,
        //   roundId
        // );

        // setEncryptedResults({
        //   weightedScore,
        //   dimensionSums,
        //   ratingCount: Number(ratingCount),
        // });
      } catch (error) {
        console.error("Failed to fetch encrypted results:", error);
      }
    },
    [ethersReadonlyProvider, skillRatingInfo, chainId, sameChain]
  );

  // Decrypt results
  const decryptResults = useCallback(
    async (rateeAddress: string, roundId: bigint) => {
      if (
        !instance ||
        !ethersSigner ||
        !skillRatingInfo.address ||
        !encryptedResults ||
        !sameChain.current(chainId) ||
        !sameSigner.current(ethersSigner)
      ) {
        return;
      }

      setIsDecrypting(true);
      setMessage("Decrypting results...");

      try {
        const thisContractAddress = skillRatingInfo.address;
        const thisEthersSigner = ethersSigner;
        const thisChainId = chainId;

        // Load or create decryption signature
        const decryptionSig = await FhevmDecryptionSignature.loadOrSign(
          instance,
          [thisContractAddress],
          thisEthersSigner,
          fhevmDecryptionSignatureStorage
        );

        if (!decryptionSig) {
          throw new Error("Failed to create decryption signature");
        }

        if (
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner)
        ) {
          setMessage("Operation cancelled");
          return;
        }

        // Prepare handles to decrypt
        const handlesToDecrypt: Array<{ handle: string; contractAddress: string }> = [];
        if (encryptedResults.weightedScore) {
          handlesToDecrypt.push({
            handle: encryptedResults.weightedScore,
            contractAddress: thisContractAddress,
          });
        }

        // Decrypt
        setMessage("Decrypting...");
        const decrypted = await instance.userDecrypt(
          handlesToDecrypt,
          decryptionSig.privateKey,
          decryptionSig.publicKey,
          decryptionSig.signature,
          decryptionSig.contractAddresses,
          decryptionSig.userAddress,
          decryptionSig.startTimestamp,
          decryptionSig.durationDays
        );

        if (
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner)
        ) {
          setMessage("Operation cancelled");
          return;
        }

        // Process decrypted results
        const results: DecryptedResults = {
          ratingCount: encryptedResults.ratingCount,
        };

        if (encryptedResults.weightedScore) {
          results.weightedScore = Number(
            decrypted[encryptedResults.weightedScore]
          );
        }

        if (encryptedResults.dimensionSums) {
          // Note: Dimension sums need to be divided by rating count
          const count = encryptedResults.ratingCount || 1;
          results.dimensions = {
            codeQuality:
              Number(decrypted[encryptedResults.dimensionSums.codeQuality]) /
              count,
            communication:
              Number(decrypted[encryptedResults.dimensionSums.communication]) /
              count,
            contribution:
              Number(decrypted[encryptedResults.dimensionSums.contribution]) /
              count,
            collaboration:
              Number(decrypted[encryptedResults.dimensionSums.collaboration]) /
              count,
            creativity:
              Number(decrypted[encryptedResults.dimensionSums.creativity]) /
              count,
          };
        }

        setDecryptedResults(results);
        setMessage("Decryption completed!");
      } catch (error) {
        console.error("Failed to decrypt results:", error);
        setMessage("Failed to decrypt results");
      } finally {
        setIsDecrypting(false);
      }
    },
    [
      instance,
      ethersSigner,
      skillRatingInfo,
      encryptedResults,
      chainId,
      sameChain,
      sameSigner,
      fhevmDecryptionSignatureStorage,
    ]
  );

  return {
    contractAddress: skillRatingInfo.address,
    currentRoundId,
    encryptedResults,
    decryptedResults,
    isSubmitting,
    isDecrypting,
    message,
    submitRating,
    fetchEncryptedResults,
    decryptResults,
  };
};

